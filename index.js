const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const axios = require('axios');
const crypto = require('crypto');

const app = express();
const PORT = process.env.PORT || 10000;

// === CONFIG ===
const SHOP = 'neko-chin-shop-5.myharavan.com';
const ACCESS_TOKEN = 'DFE528F8C4CBA1B43727A729CD57187766E059E88AE96682DC2CF04AF4F61306';
const MONGO_URI = process.env.MONGODB_URI || 'mongodb+srv://admin:admin1234@cluster0.edubkxs.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0';

// === MONGODB CONNECT ===
mongoose.connect(MONGO_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
  .then(() => console.log('‚úÖ ƒê√£ k·∫øt n·ªëi MongoDB'))
  .catch((err) => console.error('‚ùå L·ªói k·∫øt n·ªëi MongoDB:', err.message));

// === MIDDLEWARE ===
app.use(cors());
app.use(express.json());

// === SCHEMA ===
const UserPointsSchema = new mongoose.Schema({
  phone: { type: String, unique: true },
  email: String,
  total_points: { type: Number, default: 0 },
  history: [
    {
      order_id: String,
      earned_points: Number,
      timestamp: Date
    }
  ],
  missions: [
    {
      mission_key: String,   // daily_login, review_product, share_fb...
      date: Date,            // L·∫ßn cu·ªëi ho√†n th√†nh
      points: Number         // S·ªë ƒëi·ªÉm ƒë∆∞·ª£c c·ªông
    }
  ]
});
const UserPoints = mongoose.model('UserPoints', UserPointsSchema);

// === B·∫¢NG NHI·ªÜM V·ª§ (c√≥ th·ªÉ ch·ªânh ƒëi·ªÉm t√πy √Ω) ===
const MissionList = [
  // --- NHI·ªÜM V·ª§ H√ÄNG NG√ÄY ---
  { key: 'daily_login',      type: 'daily',    name: 'ƒêƒÉng nh·∫≠p m·ªói ng√†y',        points: 100,   max_per_day: 1 },
  { key: 'share_fb',         type: 'daily',    name: 'Chia s·∫ª website l√™n Facebook', points: 150,   max_per_day: 1 },
  { key: 'review_product',   type: 'daily',    name: 'ƒê√°nh gi√° s·∫£n ph·∫©m',         points: 300,   max_per_day: 3 },
  // --- NHI·ªÜM V·ª§ TH√ÅNG ---
  { key: 'monthly_order',    type: 'monthly',  name: 'Ho√†n th√†nh 5 ƒë∆°n h√†ng trong th√°ng', points: 2000,  max_per_month: 1 },
  { key: 'monthly_review',   type: 'monthly',  name: 'ƒê√°nh gi√° 5 s·∫£n ph·∫©m trong th√°ng',   points: 1500,  max_per_month: 1 },
  // --- NHI·ªÜM V·ª§ ƒê·∫∂C BI·ªÜT ---
  { key: 'referral',         type: 'special',  name: 'M·ªùi b·∫°n b√® ƒë·∫∑t ƒë∆°n ƒë·∫ßu ti√™n (c·∫£ 2 c√πng nh·∫≠n)',  points: 5000,  max_per_day: 10 },
  // ... th√™m nhi·ªám v·ª• s·ª± ki·ªán tu·ª≥ th√≠ch ...
];

// === GI·ªÆ TO√ÄN B·ªò LOGIC C≈®, B·ªî SUNG API NHI·ªÜM V·ª§ B√äN D∆Ø·ªöI ===

// === WEBHOOK: ƒê∆†N H√ÄNG HARAVAN ===
app.post('/webhook/order', async (req, res) => {
  try {
    console.log('üì¶ [Webhook] Nh·∫≠n d·ªØ li·ªáu t·ª´ Haravan:');
    console.dir(req.body, { depth: null });

    const order = req.body;
    const customer = order.customer || {};
    const billing = order.billing_address || {};
    const phone = customer.phone || billing.phone;
    const email = customer.email || null;
    const order_id = order.id?.toString();
    const total = parseInt(order.total_price || 0);
    const points = Math.floor(total / 100);

    const paid = order.financial_status === 'paid';
    const fulfilled = ['fulfilled', 'delivered'].includes(order.fulfillment_status);

    if (!phone || !paid || !fulfilled) {
      console.log(`‚ö†Ô∏è B·ªè qua ƒë∆°n kh√¥ng h·ª£p l·ªá\nSƒêT: ${phone}\nThanh to√°n: ${order.financial_status}\nGiao h√†ng: ${order.fulfillment_status}`);
      return res.status(200).send('‚ùå B·ªè qua ƒë∆°n kh√¥ng h·ª£p l·ªá');
    }

    let user = await UserPoints.findOne({ phone });

    if (user) {
      const existed = user.history.find(h => h.order_id === order_id);
      if (!existed) {
        user.total_points += points;
        user.history.push({ order_id, earned_points: points, timestamp: new Date() });
        await user.save();
      }
    } else {
      user = await UserPoints.create({
        phone,
        email,
        total_points: points,
        history: [{ order_id, earned_points: points, timestamp: new Date() }]
      });
    }

    // === Ki·ªÉm tra nhi·ªám v·ª• ƒë·∫∑c bi·ªát: Referral (B·∫°n b√® m·ªùi nhau) ===
    // B·∫°n c√≥ th·ªÉ truy·ªÅn referral_code (sdt c·ªßa ng∆∞·ªùi m·ªùi) trong order.note_attributes ho·∫∑c order.referral_code
    // M·ªói khi ng∆∞·ªùi ƒë∆∞·ª£c m·ªùi ho√†n th√†nh ƒë∆°n ƒë·∫ßu ti√™n => c·∫£ 2 c√πng nh·∫≠n
    const refAttr = (order.note_attributes || []).find(x => x.name === 'referral_code');
    const referral_code = refAttr?.value || order.referral_code; // V√≠ d·ª• b·∫°n l∆∞u m√£ gi·ªõi thi·ªáu l√† SƒêT ng∆∞·ªùi m·ªùi

    if (referral_code && referral_code !== phone) {
      // Ki·ªÉm tra ng∆∞·ªùi n√†y ƒë√£ t·ª´ng ƒë∆∞·ª£c m·ªùi b·ªüi referral_code ch∆∞a
      const alreadyGot = user.missions?.find(m => m.mission_key === 'referral' && m.date && m.referral_by === referral_code);
      if (!alreadyGot) {
        // C·ªông ƒëi·ªÉm cho ng∆∞·ªùi ƒë∆∞·ª£c m·ªùi
        user.total_points += 5000;
        user.missions = user.missions || [];
        user.missions.push({
          mission_key: 'referral',
          date: new Date(),
          points: 5000,
          referral_by: referral_code
        });
        await user.save();

        // C·ªông ƒëi·ªÉm cho ng∆∞·ªùi m·ªùi (referral_code l√† sdt)
        const inviter = await UserPoints.findOne({ phone: referral_code });
        if (inviter) {
          inviter.total_points += 5000;
          inviter.missions = inviter.missions || [];
          inviter.missions.push({
            mission_key: 'referral',
            date: new Date(),
            points: 5000,
            referral_to: phone
          });
          await inviter.save();
        }
      }
    }

    console.log(`‚úÖ C·ªông ${points} ƒëi·ªÉm cho: ${phone}`);
    res.status(200).send('ƒê√£ x·ª≠ l√Ω xong');
  } catch (err) {
    console.error('‚ùå Webhook l·ªói:', err.message);
    res.status(500).send('L·ªói webhook');
  }
});

// === API: TRA C·ª®U ƒêI·ªÇM ===
app.get('/points', async (req, res) => {
  const { phone } = req.query;
  if (!phone) return res.status(400).json({ error: 'Thi·∫øu s·ªë ƒëi·ªán tho·∫°i' });

  try {
    const user = await UserPoints.findOne({ phone });
    if (!user) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng' });

    res.json({
      phone: user.phone,
      email: user.email,
      total_points: user.total_points,
      history: user.history || [],
      missions: user.missions || []
    });
  } catch (err) {
    console.error('‚ùå L·ªói tra ƒëi·ªÉm:', err.message);
    res.status(500).json({ error: 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu ƒëi·ªÉm' });
  }
});

// === API: ƒê·ªîI ƒêI·ªÇM L·∫§Y VOUCHER ===
app.post('/redeem', async (req, res) => {
  const { phone, points } = req.body;

  if (!phone || !points || isNaN(points)) {
    return res.status(400).json({ error: 'Thi·∫øu th√¥ng tin ho·∫∑c ƒëi·ªÉm kh√¥ng h·ª£p l·ªá' });
  }

  try {
    const user = await UserPoints.findOne({ phone });
    if (!user || user.total_points < points) {
      return res.status(400).json({ error: 'Kh√¥ng ƒë·ªß ƒëi·ªÉm ƒë·ªÉ ƒë·ªïi' });
    }
    if (!user.email) {
      return res.status(400).json({ error: 'Ng∆∞·ªùi d√πng ch∆∞a c√≥ email, kh√¥ng th·ªÉ t·∫°o voucher' });
    }
    const code = 'VOUCHER-' + crypto.randomBytes(3).toString('hex').toUpperCase();
    const discountValue = points;

    const haravanResponse = await axios.post(
      `https://${SHOP}/admin/discounts.json`,
      {
        discount: {
          code: code,
          discount_type: "fixed_amount",
          value: discountValue,
          minimum_order_amount: 0,
          starts_at: new Date().toISOString(),

          // ‚úÖ Gi·ªõi h·∫°n m√£
          usage_limit: 1, // ch·ªâ d√πng 1 l·∫ßn
          customer_selection: "prerequisite", // ch·ªâ ƒë·ªãnh ng∆∞·ªùi d√πng
          prerequisite_customer_emails: [user.email] // ch·ªâ cho email n√†y d√πng
        }
      },
      {
        headers: {
          Authorization: `Bearer ${ACCESS_TOKEN}`,
          'Content-Type': 'application/json'
        }
      }
    );

    user.total_points -= points;
    user.history.push({
      order_id: `REDEEM-${code}`,
      earned_points: -points,
      timestamp: new Date()
    });

    await user.save();

    res.json({
      message: 'üéâ ƒê·ªïi ƒëi·ªÉm th√†nh c√¥ng',
      code,
      value: `${discountValue}ƒë`,
      haravan_discount: haravanResponse.data.discount
    });
  } catch (err) {
    console.error('‚ùå L·ªói ƒë·ªïi ƒëi·ªÉm:', err.response?.data || err.message);
    res.status(500).json({ error: 'Kh√¥ng t·∫°o ƒë∆∞·ª£c voucher' });
  }
});

// === API: L·∫§Y DANH S√ÅCH NHI·ªÜM V·ª§ + TR·∫†NG TH√ÅI NG∆Ø·ªúI D√ôNG ===
app.get('/missions', async (req, res) => {
  const { phone } = req.query;
  const user = await UserPoints.findOne({ phone });
  if (!user) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y user' });

  // Mapping tr·∫°ng th√°i ho√†n th√†nh
  const today = new Date().toLocaleDateString();
  const thisMonth = `${new Date().getMonth() + 1}-${new Date().getFullYear()}`;

  const missionStates = MissionList.map(mission => {
    if (mission.type === 'daily') {
      const count = (user.missions || []).filter(m =>
        m.mission_key === mission.key &&
        new Date(m.date).toLocaleDateString() === today
      ).length;
      return { ...mission, completed_today: count >= (mission.max_per_day || 1) };
    }
    if (mission.type === 'monthly') {
      const count = (user.missions || []).filter(m =>
        m.mission_key === mission.key &&
        (new Date(m.date).getMonth() + 1) === (new Date().getMonth() + 1) &&
        (new Date(m.date).getFullYear()) === (new Date().getFullYear())
      ).length;
      return { ...mission, completed_this_month: count >= (mission.max_per_month || 1) };
    }
    if (mission.type === 'special') {
      // Tu·ª≥ √Ω, kh√¥ng h·∫°n ch·∫ø
      return { ...mission };
    }
    return mission;
  });
  res.json(missionStates);
});

// === API: HO√ÄN TH√ÄNH NHI·ªÜM V·ª§ (B·∫§T K·ª≤) ===
app.post('/missions/complete', async (req, res) => {
  const { phone, mission_key } = req.body;
  const mission = MissionList.find(m => m.key === mission_key);
  if (!mission) return res.status(400).json({ error: 'Nhi·ªám v·ª• kh√¥ng t·ªìn t·∫°i' });

  const user = await UserPoints.findOne({ phone });
  if (!user) return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y user' });

  const now = new Date();

  // Logic ki·ªÉm tra gi·ªõi h·∫°n
  if (mission.type === 'daily') {
    const doneToday = (user.missions || []).filter(m =>
      m.mission_key === mission_key &&
      new Date(m.date).toLocaleDateString() === now.toLocaleDateString()
    ).length;
    if (doneToday >= (mission.max_per_day || 1)) {
      return res.json({ message: 'ƒê√£ nh·∫≠n th∆∞·ªüng nhi·ªám v·ª• h√¥m nay!' });
    }
  }
  if (mission.type === 'monthly') {
    const doneThisMonth = (user.missions || []).filter(m =>
      m.mission_key === mission_key &&
      (new Date(m.date).getMonth() + 1) === (now.getMonth() + 1) &&
      (new Date(m.date).getFullYear()) === (now.getFullYear())
    ).length;
    if (doneThisMonth >= (mission.max_per_month || 1)) {
      return res.json({ message: 'ƒê√£ nh·∫≠n th∆∞·ªüng nhi·ªám v·ª• th√°ng!' });
    }
  }

  user.total_points += mission.points;
  user.missions = user.missions || [];
  user.missions.push({ mission_key, date: now, points: mission.points });
  await user.save();

  res.json({ message: 'Nh·∫≠n th∆∞·ªüng th√†nh c√¥ng', points: mission.points, total_points: user.total_points });
});

// === START SERVER ===
app.listen(PORT, () => {
  console.log(`‚úÖ Server ƒëang ch·∫°y t·∫°i http://localhost:${PORT}`);
});
